<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>云计算 第四章</title>

    <link rel="stylesheet" href="css/include.css" media="all">

    <!-- pre-libraries -->
    <script src="js/jquery-3.6.0.min.js"></script>
    <script src="js/template-web.js"></script>

    <script src="js/define.js"></script>
  </head>
  <body>
    <div class="reveal pattern--random">
      <div class="slides">

        <script>
          courseName = "云计算";
          chapterName = "第四章 分布式技术";
          toc = [
            {name: "分布式技术概述", desc: ""},
            {name: "Redis", desc: ""},
            {name: "Redis Session分离", desc: ""},
            {name: "一致性哈希", desc: ""},
            {name: "分布式存储", desc: ""},
            {name: "分布式数据处理", desc: ""},
            {name: "Hadoop数据处理", desc: ""},
          ];
        </script>

        <section class="cover" id="cover"></section>

        <section class="toc color--midnight" id="toc"></section>

        <section class="subsection color--radiant"></section>

        <section id="what-is-distribution" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">什么是分布式？</h1>
            </div>
            <div class="content full-size" style="display: flex; flex-direction: column;">
              <p class="fragment r-fit-text">究竟什么是分布式？</p>
              <p class="fragment">分布式系统定义很多，但没有一个定义是完整的和权威的。大部分的定义都试图从不同的角度去描述分布式系统的各个方面的特性。</p>
              <div class="r-stack full-size">
                <div class="fragment fade-out collapse " data-fragment-id="group1" data-fragment-after="group1-last">
                  <blockquote class="fragment" data-fragment-id="group1-last">
                    分布式系统中，一组独立的计算机展现给用户的是一个系统来完成一个统一的工作，但是系统内部可以动态的分配任务。分散的物理和逻辑资源通过计算机网络实现信息的交换。
                  </blockquote>
                </div>
                <div class="fragment fade-out collapse " data-fragment-id="group2" data-fragment-after="group2-last">
                  <blockquote class="fragment" data-fragment-with="group1" data-fragment-id="group2-last">
                    Distribued system is a collection of independent computers that appear to the users of the system as a single computer.  --Andrew Tanenbaum
                  </blockquote>
                </div>
                <div class="fragment fade-out collapse " data-fragment-id="group3" data-fragment-after="group3-last">
                  <blockquote class="fragment" data-fragment-with="group2" data-fragment-id="group3-last">
                    Distributed system is several computers doing something together. Thus, a distributed system has three primary characteristics: multiple computers, interconnections, and shared state.  --Michael Schroeder
                  </blockquote>
                </div>
                <div>
                  <blockquote class="fragment" data-fragment-with="group3">
                    Distributed system is a collection of entities, each of which is autonomous, programmable, asynchronous and failure-prone, and which communicate through an unreliable communication medium.  --Indranil Gupta
                  </blockquote>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- what-is-distribution -->

        <section id="distributed-system-example">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">举例：分布式系统</h1>
            </div>
            <div class="content">
              <p class="fragment">例如：如要计算1+2+……+100值。</p>
              <p class="fragment">可以使用一台服务器进行<b>顺序</b>计算</p>
              <p class="fragment">也可以使用2台服务器<b>并行</b>计算，例如服务器1执行1到50的相加计算，服务器2执行51到100的相加计算，然后再进行汇总。</p>
            </div>
          </div>
        </section> <!-- distributed-system-example -->

        <section id="distributed-system-features" data-auto-animate>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式系统的特点</h1>
            </div>
            <div class="content">
              <p class="fragment">
                分布式系统的特点有很多，这里我们主要介绍其中几个：
              </p>
              <ul>
                <li class="fragment">计算速度加快</li>
                <li class="fragment">对等性</li>
                <li class="fragment">并发性</li>
                <li class="fragment">缺乏全局时钟</li>
                <li class="fragment">故障总会发生</li>
              </ul>
            </div>
          </div>
        </section> <!-- distributed-system-features -->

        <section id="distributed-system-features2" data-fragment-order data-auto-animate>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式系统的特点</h1>
            </div>
            <div class="content">
              <ul class="horizontal gap" style="margin: 0 20px;">
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group1">
                  计算速度加快
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group2" data-fragment-with="group1">
                  对等性
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group3" data-fragment-with="group2">
                  并发性
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group4" data-fragment-with="group3">
                  缺乏全局时钟
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group5" data-fragment-with="group4">
                  故障总会发生
                  </span>
                </li>
              </ul>
              <hr>
              <div class="r-stack" style="margin-top: 50px;">
                <div class="fragment full-size fade-out" data-fragment-id="group1" data-fragment-after="group1-last">
                  <p class="fragment">
                    一台服务器计算100个数的话需要用10个小时。
                  </p>
                  <p class="fragment" data-fragment-id="group1-last">
                  如果分为两台计算机，每台计算50个数，用的时间总共是5个小时，大大提高了计算的速度。
                  </p>
                </div>
                <div class="fragment full-size fade-out" data-fragment-id="group2" data-fragment-after="group2-last">
                  <p class="fragment">分布式系统中的计算机没有主/从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。</p>
                  <p class="fragment">副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。</p>
                  <p class="fragment" data-fragment-id="group2-last">
                  在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。
                  </p>
                </div>
                <div class="fragment full-size fade-out" data-fragment-id="group3" data-fragment-after="group3-last">
                  <p class="fragment" data-fragment-id="group3-last">
                  在一个计算机网络中，程序运行过程中的并发性操作，是非常常见的行为，例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。
                  </p>
                </div>
                <div class="fragment full-size fade-out" data-fragment-id="group4" data-fragment-after="group4-last">
                  <p class="fragment">
                  一个典型的分布式系统是由一系列在空间上随意分布的多个进程组成的，具有明显的分布性，这些进程之间通过交换消息来进行相互通信。
                  </p>
                  <p class="fragment" data-fragment-id="group4-last">
                  因此，在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。
                  </p>
                </div>
                <div>
                  <p class="fragment">组成分布式系统的所有计算机，都有可能发生任何形式的故障。</p>
                  <p class="fragment">一个被大量工程实践所检验过的黄金定理是：任何在设计阶段考虑到的异常情况，一定会在系统实际运行时发生，并且，在系统实际运行过程中还会遇到很多在设计时未能考虑到的异常故障。</p>
                  <p class="fragment">
                  所以，除非需求指标允许，在系统设计时不能放过任何异常情况。
                  </p>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- distributed-system-features2 -->

        <section id="distributed-cluster-diff" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式与集群的区别</h1>
            </div>
            <div class="content">
              <ul class="horizontal gap" style="margin: 0 20px;">
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group1">
                    原理上
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group2" data-fragment-with="group1">
                    容错能力上
                  </span>
                </li>
              </ul>
              <hr>
              <div class="r-stack" style="margin-top: 50px;">
                <div class="fragment full-size fade-out" style="display: flex; column-gap: 50px;" data-fragment-id="group1" data-fragment-after="group1-last">
                  <p class="fragment">
                    集群中每台服务器，可以执行的任务是一样的，相同的时间内，我们可以通过增加服务器来增加访问的人数。也就是说集群是将几台服务器集合到一起，来实现同一业务。
                  </p>
                  <p class="fragment" data-fragment-id="group1-last">
                    分布式，是按照一定的算法将任务分配给多台服务器，提高的是执行任务的时间。也就是说分布式是将不同的业务分不到不同的地方。
                  </p>
                </div>
                <div style="display: flex; column-gap: 50px;">
                  <p class="fragment">
                    集群服务器中如果有故障的服务器，可以自动隔离，问题解决后，可以自动恢复。
                  </p>
                  <p class="fragment">
                    而分布式服务器，一旦出现问题，任务就无法正常执行完成。
                  </p>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- distributed-cluster-diff -->

        <section class="subsection color--radiant">
        </section>

        <section id="nosql-basics">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">NoSQL概述</h1>
            </div>
            <div class="content">
              <p class="fragment">NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。</p>
              <p class="fragment">随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。</p>
              <p class="fragment">NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
            </div>
          </div>
        </section> <!-- no-sql-basics -->

        <section id="nosql-categories" data-auto-animate>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">NoSQL数据库的四大分类</h1>
            </div>
            <div class="content">
              <p class="fragment">
                NoSQL数据库有很多种不同的分类方式，业界比较公认的类别有四大类：
              </p>
              <ul>
                <li class="fragment">键值(Key-Value)存储数据库</li>
                <li class="fragment">列存储数据库</li>
                <li class="fragment">文档型数据库</li>
                <li class="fragment">图形(Graph)数据库</li>
              </ul>
            </div>
          </div>
        </section> <!-- nosql-categories -->

        <section id="nosql-categories2" data-auto-animate data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">NoSQL数据库的四大分类</h1>
            </div>
            <div class="content">
              <ul class="horizontal gap" style="margin: 0 20px;">
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group1">
键值(Key-Value)存储数据库
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group2" data-fragment-with="group1">
列存储数据库
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group3" data-fragment-with="group2">
文档型数据库
                  </span>
                </li>
                <li>
                  <span class="fragment dummy enlarge red" data-fragment-group="group4" data-fragment-with="group3">
图形(Graph)数据库
                  </span>
                </li>
              </ul>
              <hr>
              <div class="r-stack full-size" style="margin-top: 50px;">
                <div class="fragment full-size fade-out" data-fragment-id="group1" data-fragment-after="group1-last">
                  <ul class="full-wdith" style="margin-top: 0;">
                    <li class="fragment">典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </li>
                    <li class="fragment">数据模型： 一系列键值对</li>
                    <li class="fragment">优势： 快速查询</li>
                    <li class="fragment">劣势： 存储的数据缺少结构化</li>
                    <li class="fragment">相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</li>
                  </ul>
                  <div class="r-stack fragment" style="margin-top: 0;" data-fragment-id="group1-last">
                    <img class="animated slideInLeft" src="img/chapter004/key-value.png">
                  </div>
                </div>
                <div class="fragment r-stack full-size fade-out" data-fragment-id="group2" data-fragment-after="group2-last">
                  <ul class="full-width" style="margin-top: 0;">
                    <li class="fragment">典型应用：分布式的文件系统</li>
                    <li class="fragment">数据模型：以列簇式存储，将同一列数据存在一起</li>
                    <li class="fragment">优势：查找速度快，可扩展性强，更容易进行分布式扩展</li>
                    <li class="fragment">劣势：功能相对局限</li>
                    <li class="fragment">相关产品：Cassandra, HBase, Riak</li>
                  </ul>
                  <div class="r-stack fragment" style="margin-top: 0;" data-fragment-id="group2-last">
                    <img class="animated slideInLeft" src="img/chapter004/column.png">
                  </div>
                </div>
                <div class="fragment r-stack full-size fade-out" data-fragment-id="group3" data-fragment-after="group3-last">
                  <ul style="margin-top: 0;">
                    <li class="fragment">典型应用：Web应用（与Key-Value类似，Value是结构化的）</li>
                    <li class="fragment">数据模型： 一系列键值对</li>
                    <li class="fragment">优势：数据结构要求不严格</li>
                    <li class="fragment">劣势： 查询性能不高，而且缺乏统一的查询语法</li>
                    <li class="fragment">相关产品：CouchDB、MongoDB</li>
                  </ul>
                  <div class="r-stack fragment" style="margin-top: 0;" data-fragment-id="group3-last">
                    <img class="animated slideInLeft" src="img/chapter004/document.png">
                  </div>
                </div>
                <div class="r-stack full-size">
                  <ul style="margin-top: 0;">
                    <li class="fragment">典型应用：社交网络</li>
                    <li class="fragment">数据模型：图结构</li>
                    <li class="fragment">优势：利用图结构相关算法。</li>
                    <li class="fragment">劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li>
                    <li class="fragment">相关数据库：Neo4J、InfoGrid、Infinite Graph</li>
                  </ul>
                  <div class="r-stack fragment" style="margin-top: 0;">
                    <img class="animated slideInLeft" src="img/chapter004/graph.png">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- nosql-categories2 -->

        <section id="redis-basics">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Redis简介</h1>
            </div>
            <div class="content">
              <p class="fragment">Remote Dictionary Server(Redis)，即远程字典服务器。</p>
              <p class="fragment">Redis是ANSI C语言编写，支持网络，基于内存亦可持久化的日志型的，Key-Value数据库。</p>
              <p class="fragment">Redis是开源的且遵守BSD协议。</p>
              <p class="fragment">Redis的代码量比较小(?)方便程序员吃透其代码原理。</p>
              <p class="fragment"><b>注意</b>：学习Redis如果只是学怎么用，你就完了。</p>
              <p class="fragment">必须阅读源码，学习原理！！</p>
            </div>
          </div>
        </section> <!-- redis-basics -->

        <section id="redis-history">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Redis的历史</h1>
            </div>
            <div class="content">
              <p class="fragment">2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而该公司的创始人 Salvatore Sanfilippo（antirez）对MySQL的性能感到失望。</p>
              <p class="fragment">2009年Salvatore开发完成了Redis。同年，Salvatore Sanfilippo将Redis开源发布，并开始和另一名主要的代码贡献者Pieter Noordhuis一起继续进行Redis的维护。</p>
              <p class="fragment">Hacker News在2012年发布了一份数据库的使用情况调查显示有近12%的公司在使用Redis。</p>
              <p class="fragment">2010年VMware开始赞助Redis的开发，两名维护者也加入VMware，全职开发Redis。</p>
              <p class="fragment">从2013年开始，Redis的开发由Pivotal赞助。</p>
              <p class="fragment">2020年9月，Redis创始人Salvatore宣布离开Redis团队，但并不影响Redis的开发。（ http://antirez.com/news/133 ）</p>
            </div>
          </div>
        </section> <!-- redis-history -->

        <section id="redis-important-versions" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Redis的重大历史版本</h1>
            </div>
            <div class="content">
              <p>
                和Linux内核版本非常类似，版本号第二位如果是奇数，则为非稳定版本（例如2.7、2.9、3.1），如果是偶数，则为稳定版本（例如2.6、2.8、3.0、3.2）
              </p>
              <div style="display: flex; column-gap: 50px;">
                <ul class="fragment" style="margin: 0 0px; list-style: none; padding-right: 20px; border-right: 1px solid black;">
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group1">
                      2.6
                    </span>
                  </li>
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group2" data-fragment-with="group1">
                      2.8
                    </span>
                  </li>
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group3" data-fragment-with="group2">
                      3.0
                    </span>
                  </li>
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group4" data-fragment-with="group3">
                      3.2
                    </span>
                  </li>
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group5" data-fragment-with="group4">
                      4.0
                    </span>
                  </li>
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group6" data-fragment-with="group5">
                      5.0
                    </span>
                  </li>
                  <li>
                    <span class="fragment dummy red" data-fragment-group="group7" data-fragment-with="group6">
                      6.0
                    </span>
                  </li>
                </ul>
                <div class="r-stack" style="margin-top: 50px;">
                  <div class="fragment full-size fade-out" data-fragment-id="group1" data-fragment-after="group1-last">
                    <p class="fragment">主从结构，从节点只读</p>
                    <p class="fragment" data-fragment-id="group1-last">Lua脚本</p>
                  </div>
                  <div class="fragment full-size fade-out" data-fragment-id="group2" data-fragment-after="group2-last">
                    <p class="fragment" data-fragment-id="group2-last">
                      从节点部分复制
                    </p>
                  </div>
                  <div class="fragment full-size fade-out" data-fragment-id="group3" data-fragment-after="group3-last">
                    <p class="fragment" data-fragment-id="group3-last">
                      分布式
                    </p>
                  </div>
                  <div class="fragment full-size fade-out" data-fragment-id="group4" data-fragment-after="group4-last">
                    <p class="fragment" data-fragment-id="group4-last">
                      性能增强
                    </p>
                  </div>
                  <div class="fragment full-size fade-out" data-fragment-id="group5" data-fragment-after="group5-last">
                    <p class="fragment">
                      模块系统
                    </p>
                    <p class="fragment" data-fragment-id="group5-last">
                      支持Docker
                    </p>
                  </div>
                  <div class="fragment full-size fade-out" data-fragment-id="group6" data-fragment-after="group6-last">
                    <p class="fragment">
                      stream数据类型
                    </p>
                    <p class="fragment" data-fragment-id="group6-last">
                      C实现集群
                    </p>
                  </div>
                  <div class="full-size">
                    <p class="fragment">
                      多线程支持
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- redis-important-versions -->

        <section id="install-redis-dependency">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">安装依赖库</h1>
            </div>
            <div class="content">
 <p class="fragment">
   在安装Redis之前可能需要安装依赖：             
 </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                <script type="text/template">
yum -y install cpp
yum -y install binutils
yum -y install glibc
yum -y install glibc-kernheaders
yum -y install glibc-common
yum -y install glibc-devel
yum -y install gcc (版本必须大于5)
yum -y install make
                </script>
              </code></pre>
            </div>
          </div>
        </section> <!-- install-redis-dependency -->

        <section id="install-redis">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">安装和体验Redis</h1>
            </div>
            <div class="content">
              <p class="fragment">
                从发行版仓库中安装（版本太低）：
              </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                <script type="text/template">
yum install y redis
                </script>
              </code></pre>
              <p class="fragment">
                从源代码编译安装：
              </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                <script type="text/template">
wget http://download.redis.io/releases/redis-6.0.6.tar.gz
tar xzf redis-6.0.6.tar.gz
cd redis-6.0.6
make
make PREFIX=/usr/local/redis install
                </script>
              </code></pre>
              <p class="fragment">试用redis</p>
              <p class="fragment">https://try.redis.io/</p>
            </div>
          </div>
        </section> <!-- install-redis -->

        <section id="config-redis">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Redis的配置</h1>
            </div>
            <div class="content">
              <p class="fragment">从仓库安装，配置文件位于/etc下</p>
              <p class="fragment">从源代码安装，配置文件位于源代码路径中</p>
              <p class="fragment">为了方便，可以将配置文件复制到/etc下</p>
              <p class="fragment">可以将Redis的启动更改为服务，方便统一管理</p>
            </div>
          </div>
        </section> <!-- config-redis -->

        <section id="redis-basic-command">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Redis基础命令</h1>
            </div>
            <div class="content">
              <p class="fragment">
                获得符合规则的键名称
              </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                            <script type="text/template">
            keys 表达式（?,* ,[],\?）
                            </script>
                          </code></pre>
              <p class="fragment">
                判断一个键是否存在
              </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                            <script type="text/template">
            exists key
                            </script>
                          </code></pre>
              <p class="fragment">
                删除键
              </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                            <script type="text/template">
            del key
            del key1 key2
                            </script>
                          </code></pre>
              <p class="fragment">
                批量删除
              </p>
              <pre class="fragment"><code class="lang-sh" data-line-numbers="">
                            <script type="text/template">
            redis-cli del `redis-cli keys "key*"`
                            </script>
                          </code></pre>
              <p class="fragment">获得键值的数据类型</p>

              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                <script type="text/template">
type key
                </script>
              </code></pre>
              <p class="fragment">返回值可能是这五种类型（string,hash,list,set,zset）</p>
              <p class="fragment"><b>注意</b>：redis不区分命令大小写，区分键名大小写</p>
              <ul class="full-width" style="columns: 2;">
                <li class="fragment">help @<group>：获取组中的所有命令</li>
                <li class="fragment">help <command>：获取命令帮助</li>
                <li class="fragment">help <tab>：自动补全提示</li>
                <li class="fragment">quit：退出</li>
              </ul>
            </div>
          </div>
        </section> <!-- redis-basic-command -->

        <section id="redis-config">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Redis Config命令</h1>
            </div>
            <div class="content">
              <p class="fragment">
                使用config set可以动态设置参数信息，服务器重启之后就失效了。
              </p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                            <script type="text/template">
            config set appendonly yes
            config set save "90 1 30 10 60 100"
                            </script>
                          </code></pre>
              <p class="fragment">
                使用config get可以查看所有可以使用config set命令设置的参数
              </p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                            <script type="text/template">
            config get *
                            </script>
                          </code></pre>
              <p class="fragment">
                使用config rewrite命令对启动 Redis 服务器时所指定的 redis.conf 文件进行改写(Redis 2.8 及以上版本)，主要是把使用config set动态指定的命令保存到配置文件中。
              </p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                            <script type="text/template">
            config rewrite
                            </script>
                          </code></pre>
              <p class="fragment"><b>注意</b>：config rewrite命令对 redis.conf 文件的重写是原子性的， 并且是一致的</p>
              <p class="fragment">如果重写出错或重写期间服务器崩溃，那么重写失败，原有 redis.conf 文件不会被修改。 如果重写成功， 那么 redis.conf 文件为重写后的新文件。</p>
            </div>
          </div>
        </section> <!-- redis-config -->

        <section id="redis-install-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">演示：编译安装Redis并配置Redis服务</h1>
            </div>
            <div class="content">
              
              <div class="vh-center full-size">
                <h1>视频演示</h1>
              </div>
              <script>
                vIns.push({
                  id: "install-redis",
                  url: "video/chapter004/安装Redis_batch.mp4",
                  pauses: [0, 3.180499, 14.698534, 21.681251, 28.005284, 35.80503, 43.648694, 46.087134, 50.272359, 61.276914, 65.488669, 73.763737, 86.401038, 95.378504, 101.021244, 121.985989, 134.195466, 148.421275, 162.490382, 192.747304, 198.834438, 207.353619, 218.601174, 228.13825, 267.599774, 273.53692, 280.320557, 296.450738, 311.25426, 322.454699, 358.798, 379.170814, 404.32278, 405.512328, 413.229788, 429.138716, 437.623669, 446.881424, 453.544587]
                });
              </script>
              <div id="install-redis-video-fragment-container"></div>
            </div>
          </div>
        </section> <!-- redis-install-demo -->

        <section class="subsection color--radiant">
        </section>

        <section id="ip-hash-flaws" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">思考：IP Hash实现session保持的缺点</h1>
            </div>
            <div class="content">
              <div class="r-stack">
                <div>
                  <p class="fragment"><b>思考</b>：ip_hash方式实现session保持有什么缺点吗？</p>
                  <p class="fragment">怎么办？</p>
                  <p class="fragment">解决方法：使用session共享</p>
                  <ul>
                    <li class="fragment">
                      持久化session到数据库，即使用数据库来储存session。
                      <div class="fragment fade-out collapse full-size" data-fragment-after="group1-last">
                        <p class="fragment">数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。</p>
                        <p class="fragment">优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作 </p>
                        <p class="fragment" data-fragment-id="group1-last">
                          缺点：对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，极易造成数据库瓶颈，不适用于处理高并发的情况。
                        </p>
                      </div>
                    </li>
                    <li class="fragment">
                      <span>使用Redis共享session。</span>
                      <div class="fragment fade-out collapse full-size" data-fragment-after="group2-last">
                        <p class="fragment">
                          Redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。
                        </p>
                        <p class="fragment">
                          优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。
                        </p>
                        <p class="fragment" data-fragment-id="group2-last">
                          缺点：额外增加一些编码，以便操作redis。
                        </p>
                      </div>
                    </li>
                    <li class="fragment">
                      使用memcache同步session，
                      <div class="fragment fade-out collapse full-size" data-fragment-after="group3-last">
                        <p class="fragment">
                          memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。
                        </p>
                        <p class="fragment">
                          优点：数据储存在内存中，读取非常快，性能好；
                        </p>
                        <p class="fragment" data-fragment-id="group3-last">
                          缺点：memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。
                        </p>
                      </div>
                    </li>
                    <li class="fragment">
                      通过脚本或守护进程在多台服务器之间同步session。
                      <div class="fragment fade-out collapse full-size" data-fragment-after="group4-last">
                        <p class="fragment">
                          优点：实现了session共享；
                        </p>
                        <p class="fragment" data-fragment-id="group4-last">
                          缺点：对个人来说实现较为复杂，速度不稳定，有延时性，取决于现实中服务运行状态，偶然性较大，如果用于访问过快，可能出现session还没同步成功的情况。
                        </p>
                      </div>
                    </li>
                    <li class="fragment">
                      使用NFS共享session。
                      <div class="fragment fade-out collapse full-size" data-fragment-after="group5-last">
                        <p class="fragment">
                          NFS是Network File
                          Server共享服务器的简称，最早由Sun公司为解决Unix网络主机间的目录共享而研发。选择一台公共的NFS做共享服务器，储存所有session数据，每台服务器所需的session均从此处获取。
                        </p>
                        <p class="fragment">
                          优点：较好的实现了session共享；
                        </p>
                        <p class="fragment" data-fragment-id="group5-last">
                          缺点：成本较高，对于个人来说难以实现。NFS依托于复杂的安全机制和文件系统，因此并发效率不高。
                        </p>
                      </div>
                    </li>
                    <li class="fragment">
                      使用Cookie共享session。
                      <div class="full-size">
                        <p class="fragment">
                          如果将session中的内容存放在cookie中，则省略了服务器保存session的过程，后台只需要根据cookie中约定的标识进行鉴权校验即可。
                        </p>
                        <p class="fragment">
                          优点：完美的贯彻分布式的理念，将每个用户都利用起来，无需耗费额外的服务器资源；
                        </p>
                        <p class="fragment">
                          缺点：受http协议头长度限制，cookie中存储的信息不宜过多；
                          为了保持cookie全局有效，会占用一些服务器的带宽；
                          鉴权信息全存储于cookie中，cookie存在于客户端，其安全性比其他方案差。
                        </p>
                      </div>
                    </li>
                  </ul>
                </div>
                <div class="r-stack fragment wframe">
                  <img class="animated slideInLeft" src="img/chapter004/redis-session-topology.png">
                </div>
              </div>
            </div>
          </div>
        </section> <!-- ip-hash-flaws -->

        <section id="java-redis-dependency">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Java项目依赖Redis</h1>
            </div>
            <div class="content">
              <p class="fragment">
                对于普通项目，可以添加依赖：
              </p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                            <script type="text/template">
            compile(‘redis.clients.jedis’)
            或者
            compile(‘io.lettuce.lettue-core’)
                            </script>
                          </code></pre>
              <p class="fragment">
                对于SpringBoot项目，直接添加：
              </p>
              <pre class="fragment"><code class="lang-cpp" data-line-numbers="">
                            <script type="text/template">
            compile('org.springframework.boot:spring-boot-starter-data-redis')
                            </script>
                          </code></pre>
            </div>
          </div>
        </section> <!-- java-redis-dependency -->

        <section id="spring-session-redis">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">SpringBoot项目配置Redis Session共享</h1>
            </div>
            <div class="content">
<p class="fragment">
  在build.gradle中添加依赖：
</p>
              <pre class="fragment"><code class="lang-gradle" data-line-numbers="">
                <script type="text/template">
compile('org.springframework.boot:spring-boot-starter-data-redis')
compile('org.springframework.session:spring-session-data-redis’)
                </script>
              </code></pre>
<p class="fragment">
  在application.yml中添加配置：
</p>
              <pre class="fragment"><code class="lang-yaml" data-line-numbers="">
                <script type="text/template">
spring:
  redis:
    host: localhost
    port: 6379
    password:   
  session:
    store-type: redis
    timeout: PT10M
                </script>
              </code></pre>
            </div>
          </div>
        </section> <!-- spring-session-redis -->

        <section id="spring-session-redis-demo">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">演示：使用Redis实现Session共享</h1>
            </div>
            <div class="content full-size">
              <div class="vh-center full-size">
                <h1>视频演示</h1>
              </div>
              <script>
                vIns.push({
                  id: "redis-session",
                  url: "video/chapter004/RedisSession共享_batch.mp4",
                  pauses: [0, 13.972366, 32.187604, 46.21078, 49.935217, 59.302196, 89.580863, 100.488275, 143.915719, 152.145838, 200.588969, 257.052333, 305.955672, 335.31572, 347.661927, 355.426091, 399.751, 420.313406, 434.942, 481.627446, 540.516, 606.661926]
                });
              </script>
              <div id="redis-session-video-fragment-container"></div>
            </div>
          </div>
        </section> <!-- spring-session-redis-demo -->

        <section class="subsection color--radiant">
        </section>

        <section id="what-is-hash">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">什么是哈希</h1>
            </div>
            <div class="content">
              <p class="fragment">
                Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。
              </p>
              <div class="r-stack fragment">
                <img class="animated slideInLeft" src="img/chapter004/hash.png">
              </div>
            </div>
          </div>
        </section> <!--  -->

        <section id="cache-load-balance">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">以缓存负载均衡为例</h1>
            </div>
            <div class="content">
              <p class="fragment">缓存是存储在计算机上的一个原始数据复制集，介于数据访问者与数据源之间的一种高速存储，当数据进行读取时，直接从高速存储中获取，如果可以获取到结果时则无需访问数据库直接返回缓存中的内容；</p>
              <p class="fragment">如果缓存未命中时，再从数据库中获取，一方面可以提高数据的读取速度，另一方面还可以降低数据库的性能消耗，提高用户交互体验的同时对系统的稳定性也有了一定的保障。</p>
              <p class="fragment">
                没有缓存对系统的加速和阻挡大量的请求直接落到系统的底层，系统是很难撑住高并发的冲击，所以分布式系统中缓存的设计是很重要的一环。
              </p>
              <p class="fragment">分布式缓存最常见的方式就是通过哈希值去查找对应的数据缓存在哪个具体的服务器上。</p>
              <div class="r-stack fragment">
                <img class="animated slideInLeft" src="img/chapter004/cache-load-balance.png">
              </div>
            </div>
          </div>
        </section> <!-- cache-load-balance -->

        <section id="cache-problems">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式缓存常见问题</h1>
            </div>
            <div class="content">
              <p class="fragment"><b>缓存穿透</b>指查询一个根本不存在的数据，缓存层和存储层都不命中。一般的处理逻辑是如果存储层都不命中的话，缓存层就没有对应的数据。但在高并发场景中大量的缓存穿透，请求直接落到存储层，稍微不慎后端系统就会被压垮。所以对于缓存穿透我们有以下方案来优化。</p>
              <p class="fragment"><b>缓存雪崩</b>由于缓存层承载着大量请求，有效保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求到达存储层，存储层的调用量会暴增，造成存储层级联宕机的情况。预防和解决缓存雪崩问题可以从以下几方面入手。</p>
            </div>
          </div>
        </section> <!--  -->

        <section id="mod-hash">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">取模法</h1>
            </div>
            <div class="content">
              <div class="r-stack full-size">
                <div class="full-size">
                  <p class="fragment">哈希计算公式：key % 节点总数 = Hash节点下标 </p>
                  <p class="fragment">假设有 3 个服务器节点编号 [0 - 2]，6 个缓存键值对编号 [1 - 6]，则完成哈希映射之后，三个缓存数据映射情况如下：</p>
                  <p class="fragment">1 % 3 = 1</p>
                  <p class="fragment">2 % 3 = 2</p>
                  <p class="fragment">3 % 3 = 0</p>
                  <p class="fragment">4 % 3 = 1</p>
                  <p class="fragment">5 % 3 = 2</p>
                  <p class="fragment">6 % 3 = 0 </p>
                </div>
                <div class="r-stack fragment wframe">
                  <img class="animated slideInLeft" src="img/chapter004/mod-hash.png">
                </div>
              </div>
            </div>
          </div>
        </section> <!-- mod-hash -->

        <section id="mod-hash-problem" data-fragment-order>
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">取模法的问题</h1>
            </div>
            <div class="content">
              <p class="fragment">
                取模法实现缓存的负载均衡有什么缺陷吗？
              </p>
              <p class="fragment">
                扩展能力差：
              </p>
              <div class="fragment fade-out collapse full-size" data-fragment-after="group1-last">
                <div class="r-stack full-size">
                  <div class="full-size">
                    <p class="fragment">
                      假设新增了 1 个服务器节点，由原来的 3 个服务节点变成 4 个节点编号 [0 - 3]，哈希映射情况如下：
                    </p>
                    <p class="fragment">1 % 4 = 1</p>
                    <p class="fragment">2 % 4 = 2</p>
                    <p class="fragment">3 % 4 = 3</p>
                    <p class="fragment">4 % 4 = 0</p>
                    <p class="fragment">5 % 4 = 1</p>
                    <p class="fragment">
                      6 % 4 = 2
                    </p>
                  </div>
                  <div class="r-stack fragment wframe" data-fragment-id="group1-last">
                    <img class="animated slideInLeft" src="img/chapter004/mod-hash-add-node.png">
                  </div>
                </div>
              </div>
              <p class="fragment">
                容错能力不佳：
              </p>
              <div class="full-size">
                <div class="r-stack full-size">
                  <div class="full-size">
                    <p class="fragment">
                      假设删除 1 个服务器节点，由最初的 3 个服务节点变成 2 个，节点编号 [0 - 1]，哈希映射情况如下：
                    </p>
                    <p class="fragment">1 % 2 = 1</p>
                    <p class="fragment">2 % 2 = 0</p>
                    <p class="fragment">3 % 2 = 1</p>
                    <p class="fragment">4 % 2 = 0</p>
                    <p class="fragment">5 % 2 = 1</p>
                    <p class="fragment">6 % 2 = 0</p>
                  </div>
                  <div class="r-stack fragment wframe">
                    <img class="animated slideInLeft" src="img/chapter004/mod-hash-remove-node.png">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section> <!-- mod-hash-problem -->

        <section id="consistent-hash-basics">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">一致性哈希概述</h1>
            </div>
            <div class="content">
              <p class="fragment">一致哈希由 MIT 的 David Karger 及其合作者提出，现在这一思想已经扩展到其它领域。</p>
              <p class="fragment">在这篇1997年发表的学术论文中介绍了一致哈希如何应用于用户易变的分布式Web服务中。</p>
              <p class="fragment">一致哈希也可用于实现健壮缓存来减少大型Web应用中系统部分失效带来的负面影响。</p>
              <p class="fragment">一句话概括一致性哈希：就是普通取模哈希算法的改良版，哈希函数计算方法不变，只不过是通过构建环状的 Hash 空间代替普通的线性 Hash 空间。</p>
              <p class="fragment">
                一致性哈希由以下步骤组成：
              </p>
            </div>
          </div>
        </section> <!-- consistent-hash-basics -->

        <section id="consistent-hash-space">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">哈希空间环</h1>
            </div>
            <div class="content">
              <p class="fragment">
                选择一个足够大的Hash空间（一般是 0 ~ 2^32）构成一个哈希环。
              </p>
              <div class="r-stack fragment">
                <img class="animated slideInLeft" src="img/chapter004/hash-ring.png">
              </div>
            </div>
          </div>
        </section> <!-- hash-space -->

        <section id="consistent-hash-calculate-cache-server">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">计算缓存服务器位置</h1>
            </div>
            <div class="content">
              <p class="fragment">
                对于缓存集群内的每个存储服务器节点计算 Hash 值，可以用服务器的 IP 或 主机名计算得到哈希值，计算得到的哈希值就是服务节点在 Hash 环上的位置。
              </p>
              <div class="r-stack fragment">
                <img class="animated slideInLeft" src="img/chapter004/server-location.png">
              </div>
            </div>
          </div>
        </section> <!-- calculate-cache-server -->

        <section id="consistent-hash-calculate-cache-key">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">计算缓存key的位置</h1>
            </div>
            <div class="content">
              <p class="fragment">
                对每个需要存储的数据 key 同样也计算一次哈希值，计算之后的哈希也映射到环上。
              </p>
              <p class="fragment">
                数据存储在具体哪个缓存服务器上是沿顺时针的方向找到的环上的第一个服务器节点。
              </p>
              <div class="r-stack fragment">
                <img class="animated slideInLeft" src="img/chapter004/key-location.png">
              </div>
            </div>
          </div>
        </section> <!-- calculate-cache-key -->

        <section id="consistent-hash-add-node">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">增加缓存节点</h1>
            </div>
            <div class="content">
              <div class="r-stack">
                <img class="fragment" src="img/chapter004/consistent-hash-add-node.png" alt="">
              </div>
              <p class="fragment">
                当缓存服务集群要新增一个节点node3时，受影响的只有 key3 对应的数据 value3，此时只需把 value3 由原来的节点 node0 迁移到新增节点 node3 即可，其余节点存储的数据保持不动。
              </p>
            </div>
          </div>
        </section> <!-- add-node -->

        <section id="consistent-hash-remove-node">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">删除节点</h1>
            </div>
            <div class="content">
              <div class="r-stack">
                <img class="fragment" src="img/chapter004/consistent-hash-remove-node.png" alt="">
              </div>
              <p class="fragment">
                假设 node2 节点宕机下线，则原来存储于 node2 的数据 value2 和 value5 ，只需按顺时针方向选择新的存储节点 node0 存放即可，不会对其他节点数据产生影响。一致性哈希能把节点宕机造成的影响控制在顺时针相邻节点之间，避免对整个集群造成影响。
              </p>
            </div>
          </div>
        </section> <!-- consistent-hash-remove-node -->

        <section id="consistent-hash-flaws">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">思考</h1>
            </div>
            <div class="content">
              <p class="fragment">
                <b>思考</b>：一致性哈希还存在缺陷吗？
              </p>
              <p class="fragment">
                若缓存集群内的服务节点比较少，就像我们例子中的三个节点，而哈希环的空间又有很大（一般是 0 ~ 2^32），这会导致什么问题呢？
              </p>
            </div>
          </div>
        </section> <!-- consistent-hash-flaws -->

        <section id="data-lean">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">数据倾斜问题</h1>
            </div>
            <div class="content">
              <p class="fragment">较少的服务节点哈希值聚集在一起，比如只有三个节点node0 、node1、node2 聚集在一起，则可能出现缓存大部分数据的 key 哈希都映射到同一个节点上，</p>
              <p class="fragment">这种情况称为数据倾斜。给单个节点很大的压力！</p>
              <div class="r-stack">
                <img class="fragment" src="img/chapter004/consistent-hash-data-lean.png" alt="">
              </div>
            </div>
          </div>
        </section> <!-- data-lean -->

        <section id="virtual-node">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">虚拟节点</h1>
            </div>
            <div class="content">
              <p class="fragment">所谓虚拟节点，就是对原来单一的物理节点在哈希环上虚拟出几个它的分身节点，这些分身节点称为「虚拟节点」。</p>
              <p class="fragment">打到分身节点上的数据实际上也是映射到分身对应的物理节点上，这样一个物理节点可以通过虚拟节点的方式均匀分散在哈希环的各个部分，解决了数据倾斜问题。</p>
              <p class="fragment">由于虚拟节点分散在哈希环各个部分，当某个节点宕机下线，他所存储的数据会被均匀分配给其他各个节点，避免对单一节点突发压力导致的节点雪崩问题。</p>
              <div class="r-stack">
                <img class="fragment" src="img/chapter004/virtual-node.png" alt="">
              </div>
            </div>
          </div>
        </section> <!-- virtual-node -->

        <section class="subsection color--radiant">
        </section>

        <!-- for chat box -->
        <style>
        .msg-box-right {
          width: 400px;
          background-color: #04BE02;
          border-radius: 6px;
          position: relative;
          border: 1px solid lightgray;
          padding: 10px;
        }
        .msg-box-right::before{
          position: absolute;
          top: calc(50% - 5px);
          left: 100%;
          content: '';
          border-width: 10px;
          border-style: solid;
          border-top-color: transparent;
          border-right-color: transparent;
          border-bottom-color: transparent;
          border-left-color: lightgray;
        }
        .msg-box-right::after {
          position: absolute;
          top: calc(50% - 5px);
          left: calc(100% - 0.5px);
          content: '';
          border-width: 10px;
          border-style: solid;
          border-top-color: transparent;
          border-right-color: transparent;
          border-bottom-color: transparent;
          border-left-color: #04BE02;
        }

        .msg-box-left {
          width: 400px;
          background-color: #fff;
          border-radius: 6px;
          position: relative;
          border: 1px solid gray;
          padding: 10px;
          margin-left: 10px;
        }
        .msg-box-left::before{
          position: absolute;
          top: calc(50% - 5px);
          left: -20px;
          content: '';
          border-width: 10px;
          border-style: solid;
          border-top-color: transparent;
          border-right-color: gray;
          border-bottom-color: transparent;
          border-left-color: transparent;
        }
        .msg-box-left::after {
          position: absolute;
          top: calc(50% - 5px);
          left: -18.5px;
          content: '';
          border-width: 10px;
          border-style: solid;
          border-top-color: transparent;
          border-right-color: #fff;
          border-bottom-color: transparent;
          border-left-color: transparent;
        }
        </style>

        <section id="distributed-storage" data-auto-animate="">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式数据存储</h1>
            </div>
            <div class="content full-height">
              <p class="fragment fade-out">我们用以下场景来帮助大家理解分布式数据存储：</p>
              <div id="ds-chat-container" class="full-height" 
                style="display: grid; grid-template-areas: 'left1 right1' 'left2 right2'; align-items: center; grid-row-gap: 70px;">
                <script id="ds-chat" type="text/html">
                  <div class="msg-box-left fragment fade-in-then-out" style="grid-area: left1;">
                    <p>{{@rx}}</p>
                  </div>
                  <div class="msg-box-right fragment fade-in-then-out" style="grid-area: right2;">
                    <p>{{@tx}}</p>
                  </div>
                </script>
              </div>
            </div>
          </div>
        </section>

        <section id="distributed-storage2" data-auto-animate="">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式数据存储</h1>
            </div>
            <div class="content full-height">
              <p class="fragment fade-out">几个月后……</p>
              <div id="ds-chat-container2" class="full-height"
                style="display: grid; grid-template-areas: 'left1 right1' 'left2 right2'; align-items: center; grid-row-gap: 70px;">
              </div>
            </div>
          </div>
        </section>

        <script>
          var ds_chats = [
            {
              rx: "帮我保存一下这几天的数据。",
              tx: "好嘞，有多大呢？"
            },
            {
              rx: "1T",
              tx: "好没问题，买个硬盘就搞定了。"
            },
          ];
          var ds_chats2 = [
            {
              rx: "帮我保存下这几个月的数据。",
              tx: "好嘞，这次有多大呢？"
            },
            {
              rx: "1024T",
              tx: "哇，这么大吗？没有这么大的硬盘卖呀，而且好像也没听过<b>一台计算机</b>可以存放<b>1024T</b>的数据。"
            },
            {
              rx: "那怎么办？",
              tx: "对了，我可以部署1024台计算机，然后用网络将他们连接起来，让他们的数据可以共享，这不就可以了吗？机智如我。"
            },
            {
              rx: "我们应该怎么称呼这种存储方式呢？",
              tx: "就叫做<b>分布式存储</b>吧，因为数据是分布存储于不同的计算上。"
            },
          ];
        </script>

        <section id="distributed-storage3">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式数据存储</h1>
            </div>
            <div class="content">
              <ul>
                <li>当数据集的大小<b>远远超过</b>一台独立的物理计算机的存储能力时，就有必要对它进行分区并存储到若干台单独的计算机上</li>
                <li class="fragment">用来管理网络中跨多台计算机存储的文件系统称为<b>分布式文件系统</b>(Distributed File System)。</li>
                <li class="fragment">大数据处理技术<b>必然</b>和分布式存储协同工作，在大数据领域常用的分布式文件系统为HDFS (Hadoop Distributed File System)。</li>
                <li class="fragment">HDFS实际上是Google内部所使用的GFS的一种开源实现版本。</li>
              </ul>
            </div>
          </div>
        </section>

        <section id="hdfs-principles">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">HDFS基本原理</h1>
            </div>
            <div class="content">
              <div class="r-stack">
                <div class="full-width full-height">
                  <p>
                    HDFS有两类节点用来管理集群的数据:
                  </p>
                  <ul>
                    <li class="fragment">namenode，管理节点或命名节点
                      <ul>
                        <li class="fragment">管理文件系统的命名空间</li>
                        <li class="fragment">维护系统文件树及整棵树内所有的文件和目录关系（永久保存）</li>
                        <li class="fragment">记录每个文件中各个块所在的数据节点信息（启动时重建）</li>
                      </ul>
                    </li>
                    <li class="fragment">datanode，工作节点或数据节点
                      <ul>
                        <li class="fragment">以数据块的形式存储具体的数据</li>
                        <li class="fragment">定期向namenode发送其所存储的数据块的列表</li>
                      </ul>
                    </li>
                  </ul>
                </div>
                <img class="fragment" src="img/hdfs-arch.png" 
                  style="border: 1px solid black;"
                  alt="HDFS原理图">
              </div>
            </div>
          </div>
        </section>

        <section id="hdfs-principles2">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">HDFS基本原理：举例</h1>
            </div>
            <div class="content full-height">
              <div id="ds-chat-container3" class="full-height"
                style="display: grid; grid-template-areas: 'left1 right1' 'left2 right2'; align-items: center; grid-row-gap: 70px;">
              </div>
            </div>
          </div>
        </section>


        <script>
          var ds_chats3 = [
            {
              rx: "……可你说的我都听不懂啊？",
              tx: "额，我们现在将咱们的大数据存储空间想象成一个<b>大仓库</b>，仓库很大，有很多货架。"
            },
            {
              rx: "哦，这个比较好懂。",
              tx: "有一本<b>总账单</b>记录着仓库所有货架的商品，每一个货架上都放了很多货物，不过这些货物有一个特点，即<b>大小都一致</b>。"
            },
            {
              rx: "嗯，总账本实际上就是namenode所维护的关于存储数据的数据吧？",
              tx: "对！这种关于数据的数据叫做元数据（Meta-data）。"
            },
            {
              rx: "那货架上的<b>货物</b>其实指的就是<b>数据块</b>吧？",
              tx: "对！"
            },
            {
              rx: "那每个货物是多大呢？",
              tx: "货物的大小是可以根据货架调整的。默认情况下，数据块的大小是<b>128MB</b>。每个数据块不能超过这个大小。我们可以把datanode想象成货架，那么每个货架上还要再维护一个<b>货架清单</b>。"
            },
            {
              rx: "好像懂了，但为什么有了总清单还需要货架清单呢？",
              tx: "货架清单记录的是<b>本货架</b>上的物品信息。每次货架上货或者出货，总是先更新本货架清单，然后货架清单再定期通知主清单。"
            },
            {
              rx: "为什么呢要先更新货架清单再定期更新总清单？",
              tx: "因为每个货架离总清单可能很远，每次报告总清单总会需要通信延迟。而等累计一定量的数据之后再汇总更新总清单会比较高效。"
            },
            {
              rx: "我感觉我好像懂了。那我是不是已经理解了分布式存储技术了。",
              tx: "可以这么说，但这只是一些基本概念，实际情况比这要复杂很多。"
            },
            {
              rx: "还有哪些复杂情况？",
              tx: "比如为了防止数据从一个货架上丢失，数据总是以三个副本的方式存储在不同的货架上。也因此需要考虑货物的同步（一致性）问题。类似的问题在分布式数据存储中还有很多。"
            },
          ];

          ///////// generate distributed-storage chat /////////
          var dsChat = document.querySelector('#ds-chat-container');
          for(var i = 0; i < ds_chats.length; i++) {
            var chat = ds_chats[i];
            var chatContent = template('ds-chat', chat);
            dsChat.innerHTML += chatContent;
          }
          var dsChat2 = document.querySelector('#ds-chat-container2');
          for(var i = 0; i < ds_chats2.length; i++) {
            var chat = ds_chats2[i];
            var chatContent = template('ds-chat', chat);
            dsChat2.innerHTML += chatContent;
          }
          var dsChat3 = document.querySelector('#ds-chat-container3');
          for(var i = 0; i < ds_chats3.length; i++) {
            var chat = ds_chats3[i];
            var chatContent = template('ds-chat', chat);
            dsChat3.innerHTML += chatContent;
          }
        </script>

        <section id="intro-distrated-data-processing">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分布式数据处理</h1>
            </div>
            <div class="content">
              <ul>
                <li>使用分布式数据存储可以解决大数据存储的问题。</li>
                <li class="fragment">那么如何使用分布式数据处理解决大数据处理的问题呢？</li>
                <li class="fragment">分布式数据处理当中有一个重要的思想叫：<b>分治法</b> (Divide and Conquer)。</li>
              </ul>
            </div>
            </div>
        </section>

        <section id="divide-and-conquer">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分治法</h1>
            </div>
            <div class="content">
              <ul>
                <li class="fragment">分治法的主要思想就是将一个复杂的问题分成两个或多个相同的子问题，</li>
                <li class="fragment">子问题可以分成更小的子问题，</li>
                <li class="fragment">直到子问题可以容易解决的时候，原问题的解就是子问题解的整合。</li>
                <li class="fragment">
                  分治法解决一个问题主要包括以下步骤：
                  <ul>
                    <li class="fragment">分：将复杂的问题分解为规模较小的子问题；</li>
                    <li class="fragment">治：将这些规模较小的问题逐个解决；</li>
                    <li class="fragment">合：将已经解决的子问题合并，得出最终问题的解。</li>
                  </ul>
                </li>
                <li class="fragment">
                  以上三个步骤中每个步骤都很重要。
                </li>
                <li class="fragment">
                  分治法的最优情况是：如果分开的子问题之间相互之间无依赖性，那么这些子问题就可以使用不同的计算机<b>并行</b>解决。
                </li>
              </ul>
            </div>
          </div>
        </section>

        <section id="divide-and-conquer-example1">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分治法举例</h1>
            </div>
            <div class="content">
              <div>
                <p>下面通过一个简单易懂的小例子来理解分治法。</p>
                <p class="fragment"><b>问题</b>：要求1+2+3+4+……+10的结果。</p>
                <ul>
                  <li class="fragment">分：把问题分为两个更小的模块的子问题，发现这两个子问题都可以被分别求，且两者之间无相互依赖：
                    <ul class="fragment">
                      <li>1+2+3+4+5</li>
                      <li>6+7+8+9+10</li>
                    </ul>
                  </li>
                  <li class="fragment">治：分别用两台计算机上对两个子问题进行求解：
                    <ul class="fragment">
                      <li>1+2+3+4+5 = 15</li>
                      <li>6+7+8+9+10 = 40</li>
                    </ul>
                  </li>
                  <li class="fragment">合：把两个子问题的解聚合到同一台计算机上再求解，就得到最终结果
                    <ul class="fragment">
                      <li>15+40=55</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        <section id="divide-and-conquer-example2">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">分治法举例</h1>
            </div>
            <div class="content">
              <p> <b>思考</b>：如果把问题分为更小规模，用更多的计算机同时求解，处理速度是否更快？</p>
              <ul class="fragment full-width">
                <li>1+2</li>
                <li>3+4</li>
                <li>5+6</li>
                <li>7+8</li>
                <li>9+10</li>
              </ul>
              <ul>
                <li class="fragment">只要通过5台计算机同时运行，得到5个结果。然后再使用3台计算机同时运算，最终再把结果汇总，计算最终结果。</li>
                <li class="fragment">那是不是参与运算的计算机越多，计算效率就越高呢？</li>
              </ul>
            </div>
          </div>
        </section>

        <section id="applicable">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">适用条件</h1>
            </div>
            <div class="content">
              <ul>
                <li>
                  分治所能解决的问题一般具有以下几个特征：
                  <ul>
                    <li class="fragment">该问题的规模缩小到一定的程度就可以容易地解决；</li>
                    <li class="fragment">该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li>
                    <li class="fragment">利用该问题分解出的子问题的解可以合并为该问题的解；</li>
                    <li class="fragment">该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </section>

        <section class="subsection color--radiant">
        </section>

        <section id="hadoop-intro">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">Hadoop技术简介</h1>
            </div>
            <div class="content">
              <div class="r-stack">
                <img class="animated flipInX" src="img/hadoop.png" alt="大数据" style="height: 90%;">
              </div>
              <ul>
                <li class="fragment">Hadoop 是一种分析和处理大数据的软件平台，是一个用 Java 语言实现的 Apache 的开源软件框架，在大量计算机组成的集群中实现了对海量数据的分布式计算。</li>
                <li class="fragment">Hadoop 采用 MapReduce 分布式计算框架，根据 GFS 原理开发了 HDFS（分布式文件系统），并根据 BigTable 原理开发了 HBase 数据存储系统。</li>
                <li class="fragment">Hadoop 和 Google 内部使用的分布式计算系统原理相同，其开源特性使其成为分布式计算系统的事实上的国际标准。</li>
              </ul>
            </div>
          </div>
        </section>

        <section id="map-reduce-intro">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">MapReduce技术简介</h1>
            </div>
            <div class="content">
              <div class="r-stack">
                <ul>
                  <li>
                    实际大数据编程中，主要使用MapReduce模型来实现分治法
                  </li>
                  <li class="fragment">如果我们需要统计一个班上大学英语六级成绩最高的同学，那么我们通过一台计算机很快就能算出来</li>
                  <li class="fragment">但如果我们需要统计全中国近3年内大学英语六级成绩最高的同学，那么使用一台计算机来做会需要很长时间</li>
                  <li class="fragment">我们可以考虑同时使用多台计算机来并行完成统计工作：</li>
                  <ul>
                    <li class="fragment">例如，我们使用3台计算机来同时工作</li>
                    <li class="fragment">将所有学生的成绩平均分成3个组</li>
                    <li class="fragment">然后分别（并行）查找这3组数据中的最大值——Map阶段</li>
                    <li class="fragment">分别处理完成之后再对这些数据进行合并——Merge阶段</li>
                    <li class="fragment">最后再对这些数据再查找最大值——Reduce阶段</li>
                  </ul>
                </ul>
                <img class="fragment" style="border: 1px solid black;" src="img/mapreduce.png" alt="MapReduce过程">
              </div>
            </div>
          </div>
        </section>

        <section id="map-reduce-sandwhich">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">MapReduce的奇妙比喻</h1>
            </div>
            <div class="content full-height">
              <div class="r-stack full-height">
                <div class="fragment fade-in-then-out">
                  <img class="animated zoomIn" src="img/sandwhich.png" alt="创造101">
                </div>
              </div>
            </div>
          </div>
        </section>

        <section class="subsection color--radiant">
        </section>

        <section id="hadoop-implementation">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">MapReduce的代码实现原理</h1>
            </div>
            <div class="content">
              <p>Hadoop软件架构已经帮我们实现好了整个MapReduce的框架</p>
              <p>一般情况下，用户仅仅需要完成Map和Reduce两个过程的代码</p>
              <p>对于简单的项目，Shuffle、Combine和Sort过程Hadoop都有默认实现</p>
              <p class="fragment">要实现Map过程，主要通过继承Hadoop提供的Mapper类：</p>
              <pre class="fragment"><code class="lang-java" data-line-numbers="">
<script type="text/template">
  Mapper<KeyIn, ValueIn, KeyOut, ValueOut>
</script>
              </code></pre>
              <p class="fragment">Mapper类需要指定四个泛型参数：</p>
              <ul>
                <li class="fragment">KeyIn：输入的键类型</li>
                <li class="fragment">ValueIn：输入的值类型</li>
                <li class="fragment">KeyOut：输出的键类型</li>
                <li class="fragment">ValueOut：输出的值类型</li>
              </ul>
              <p class="fragment">此外，必须实现Mapper类的map()方法:</p>
              <pre class="fragment"><code class="lang-java" data-line-numbers="">
<script type="text/template">
public void map(KeyIn key, ValueIn value, Context context
    ) throws IOException, InterruptedException
</script>
              </code></pre>
            </div>
          </div>
        </section>

        <section id="word-count-mapper">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">WordCount的Mapper实现</h1>
            </div>
            <div class="content">
              <div class="code-tips" style="display:none;">
                <p class="code-tip" data-code-line-numbers="2">
                  - Object：输入的建类型，这里主要指输入的行在文件中的偏移量（本程序中无用）<br>
                  - Text：输入的值类型，这里是一行文本<br>
                  - Text：输出的键类型，这里主要是每个单词，是文本类型<br>
                  - IntWritable：输出的值类型，这里主要是单词出现的次数，是整型
                </p>
                <p class="code-tip" data-code-line-numbers="4,5">设定每个单词默认出现次数是1</p>
                <p class="code-tip" data-code-line-numbers="8">重写map()方法：<br>
                  - key：输入的行在整个文件中的偏移量（不使用）<br>
                  - value：输入的一行文本<br>
                  - context：输入上下文，把处理的结果输出到其中，会自动传递到下一个流程
                </p>
                <p class="code-tip" data-code-line-numbers="10">以空格为分隔符把一行文字拆分成多个单词</p>
                <p class="code-tip" data-code-line-numbers="11">遍历分隔出来的所有单词</p>
                <p class="code-tip" data-code-line-numbers="12">取出单词作为输出的键</p>
                <p class="code-tip" data-code-line-numbers="13">向Context输出键和值</p>
              </div>
<pre style="height: 600px;"><code class="lang-java" 
   data-line-numbers="0|2|4,5|8|10|11|12|13">
<script type="text/template">
  public class TokenizerMapper 
     extends Mapper<Object, Text, Text, IntWritable>{

    private final static IntWritable one = 
      new IntWritable(1);
    private Text word = new Text();

    public void map(Object key, Text value, Context context
        ) throws IOException, InterruptedException {
      StringTokenizer itr = new StringTokenizer(value.toString());
      while (itr.hasMoreTokens()) {
        word.set(itr.nextToken());
        context.write(word, one);
      }
    }
  }
</script>
             </code></pre> 
            </div>
          </div>
        </section>

        <section id="hadoop-implementation2">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">MapReduce的代码实现原理</h1>
            </div>
            <div class="content">
              <p>在Map过程处理完的数据在经过Combiner和Shuffle过程之后，会到达Reduce过程</p>
              <p class="fragment">要实现Reduce过程，主要通过继承Hadoop提供的Reducer类：</p>
              <pre class="fragment"><code class="lang-java" data-line-numbers="">
<script type="text/template">
  Reducer<KeyIn, ValueIn, KeyOut, ValueOut>
</script>
              </code></pre>
              <p class="fragment">Reducer类也需要指定四个泛型参数：</p>
              <ul>
                <li class="fragment">KeyIn：输入的键类型</li>
                <li class="fragment">ValueIn：输入的值类型</li>
                <li class="fragment">KeyOut：输出的键类型</li>
                <li class="fragment">ValueOut：输出的值类型</li>
              </ul>
              <p class="fragment">此外，必须实现Reducer类的reduce()方法:</p>
              <pre class="fragment"><code class="lang-java" data-line-numbers="">
<script type="text/template">
 public void reduce(Text key, 
     Iterable<IntWritable> values, Context context
     ) throws IOException, InterruptedException 
</script>
              </code></pre>
            </div>
          </div>
        </section>

        <section id="word-count-reducer">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">WordCount的Reducer实现</h1>
            </div>
            <div class="content">
              <div class="code-tips" style="display:none;">
                <p class="code-tip" data-code-line-numbers="2">
                  - Text：输入的键类型，此处为单词<br>
                  - IntWritable：输入的值，此处为单词出现的次数<br>
                  - Text：输出的键类型，此处也为单词<br>
                  - IntWritable：输出的值类型，此处为该单词累加之后的结果，是一个整数
                </p>
                <p class="code-tip" data-code-line-numbers="5,6">
                  - key是单词<br>
                  - values是单词出现的次数的序列，例如&lt;hello, 1, 2, 1, 3, 5&gt;
                  - context存储reduce阶段的输出
                </p>
                <p class="code-tip" data-code-line-numbers="8-11">对同一个单词的各个出现次数序列进行累加</p>
                <p class="code-tip" data-code-line-numbers="13">输出单词对应的总出现次数</p>
              </div>
<pre style="height:600px;"><code class="lang-java" 
  data-line-numbers="0|2|5,6|8-11|13">
<script type="text/template">
public static class IntSumReducer 
   extends Reducer<Text,IntWritable,Text,IntWritable> {
  private IntWritable result = new IntWritable();

  public void reduce(Text key, 
    Iterable<IntWritable> values, Context context
     ) throws IOException, InterruptedException {
    int sum = 0;
    for (IntWritable val : values) {
      sum += val.get();
    }
    result.set(sum);
    context.write(key, result);
  }
}
</script>
              </code></pre>
            </div>
          </div>
        </section>

        <section id="hadoop-main-function">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">WordCount的主程序</h1>
            </div>
            <div class="content">
              <div class="code-tips" style="display:none;">
                <p class="code-tip" data-code-line-numbers="3">获取执行这个任务时传入的参数，如输入数据所在路径、输出文件的路径的等</p>
                <p class="code-tip" data-code-line-numbers="6-8">判断参数是否正确</p>
                <p class="code-tip" data-code-line-numbers="10">实例化job，传入参数，job的名字叫 word count</p>
                <p class="code-tip" data-code-line-numbers="11">加载主类</p>
                <p class="code-tip" data-code-line-numbers="12">设置Mapper类</p>
                <p class="code-tip" data-code-line-numbers="13">设置Combiner类</p>
                <p class="code-tip" data-code-line-numbers="14">设置Reducer类</p>
                <p class="code-tip" data-code-line-numbers="15">设置输出的键类型</p>
                <p class="code-tip" data-code-line-numbers="16">设置输出的值类型</p>
                <p class="code-tip" data-code-line-numbers="17-19">设置输入文件路径</p>
                <p class="code-tip" data-code-line-numbers="20,21">设置输出文件路径</p>
                <p class="code-tip" data-code-line-numbers="22">等待任务完成，任务完成之后退出程序</p>
              </div>
<pre style="height: 600px;"><code class="lang-java" 
  data-line-numbers="0|3|6-8|10|11|12|13|14|15|16|17-19|20,21|22">
<script type="text/template">
public static void main(String[] args) throws Exception {
  Configuration conf = new Configuration();    
  String[] otherArgs = 
      new GenericOptionsParser(conf, args)
      .getRemainingArgs();
  if (otherArgs.length < 2) {
    System.err.println("Usage: wordcount <in> [<in>...] <out>");
    System.exit(2);
  }
  Job job = Job.getInstance(conf, "word count");
  job.setJarByClass(WordCount.class);
  job.setMapperClass(TokenizerMapper.class);
  job.setCombinerClass(IntSumReducer.class);
  job.setReducerClass(IntSumReducer.class);
  job.setOutputKeyClass(Text.class);
  job.setOutputValueClass(IntWritable.class);
  for (int i = 0; i < otherArgs.length - 1; ++i) {
    FileInputFormat.addInputPath(job, new Path(otherArgs[i]));
  }
  FileOutputFormat.setOutputPath(job,
    new Path(otherArgs[otherArgs.length - 1]));
  System.exit(job.waitForCompletion(true) ? 0 : 1);
}
</script>
              </code></pre>
            </div>
          </div>
        </section>


        <section id="hadoop-python-mapper">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">mapper Python版程序</h1>
            </div>
            <div class="content">
<pre style="height: 600px;"><code class="lang-python" data-code-tips>
<script type="text/template">
#  RainSia::tip {{{导入系统模块，为了使用标准输入和标准输出}}} RainSia::end
import sys

#  RainSia::tip {{{从标准输入当中读取一行}}} RainSia::end
for line in sys.stdin:
  #  RainSia::tip {{{去掉一行的头部和尾部的空格}}} RainSia::end
  line = line.strip()
  #  RainSia::tip {{{把每一行以空格切割成单词}}} RainSia::end
  words = line.split()
  
  #  RainSia::tip {{{循环打印每个单词到标准输出}}} RainSia::end
  for word in words:
    #  RainSia::tip {{{打印每个单词及其计数，默认每个单词出现一次}}} RainSia::end
    print('%s\t%s' % (word, 1))
</script>
              </code></pre>
            </div>
          </div>
        </section>

        <section id="hadoop-python-reducer">
          <div class="grid-wrapper">
            <div class="header">
              <div class="logo"></div>
              <h1 class="header">reducer Python版程序</h1>
            </div>
            <div class="content">
<pre style="height: 600px;"><code class="lang-python" data-code-tips>
<script type="text/template">
current_word = None
current_count = 0
word = None

# RainSia::tip {{{从系统标准输入中读取每一行}}} RainSia::end
for line in sys.stdin:
  #  RainSia::tip {{{去掉每一行开头和结尾的空格}}} RainSia::end
  line = line.strip()
  # RainSia::tip {{{以\t为分隔符，将每一行分成两个部分，前面是单词，后面是出现个数}}} RainSia::end
  word, count = line.split('\t', 1)

  # RainSia::tip {{{将单词计数，从字符串转换为数字}}} RainSia::end
  try:
    count = int(count)
  except ValueError:
    # RainSia::tip {{{如果转换出错，则继续}}} RainSia::end
    continue

  # RainSia::tip {{{将相同的单词进行累计}}} RainSia::end
  if current_word == word:
    current_count += count
  else:
    if current_word:
      # RainSia::tip {{{输出单词及其计数}}} RainSia::end
      print('%s\t%s' % (current_word, current_count))
    current_count = count
    current_word = word

# RainSia::tip {{{输出最后一个单词}}} RainSia::end
if current_word == word:
  print('%s\t%s' % (current_word, current_count))
</script>
              </code></pre>
            </div>
          </div>
        </section>

        <section id="thank-you-slide" class="end color--radiant"></section>

      </div> <!-- slides -->
    </div> <!-- reveal -->

    <script>
      language = 'cn';

      var myConfig = {
        "math": math, 
        "asciinema": {
          rows: 24,
          cols: 81
        }
      };

      defineMyPlugins = function() {
        myPreloadPlugins = [
          /**** my plugins ****/
          RevealLoadCode, RevealFragmentOrder,
        ];
        myPlugins = [
          /**** built-in plugins ****/
          /**** third-party plugins ****/
          /**** my plugins ****/
          RevealCodeTips, RevealFragmentGroup,
        ];
      };
    </script>
    <script src="js/common.js"></script>
  </body>
</html>
